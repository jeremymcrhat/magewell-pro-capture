
/*
 * GPL header
 */

#ifndef __video_h
#define __video_h

#include "v4l2-sg-buf.h"
#include "pcie-dma-desc-chain.h"

void video_capture_SetIntEnables(struct mag_cap_dev *mdev,
					unsigned long enable_bits);

unsigned long video_capture_GetIntRawStatus(struct mag_cap_dev *mdev);
void video_capture_ClearIntRawStatus(struct mag_cap_dev *mdev, unsigned long dwClearBits);

enum VIDEO_REG_ADDR {
    VIDEO_REG_ADDR_VER_CAPS					= 4 * 0,

    VIDEO_REG_ADDR_INT_ENABLE					= 4 * 1,
    VIDEO_REG_ADDR_INT_STATUS					= 4 * 2,
    VIDEO_REG_ADDR_INT_RAW_STATUS				= 4 * 3,

    VIDEO_REG_ADDR_RESET						= 4 * 4,

    VIDEO_REG_ADDR_CONTROL_PORT				= 4 * 5,
    VIDEO_REG_ADDR_CONTROL_PORT_SET			= 4 * 6,
    VIDEO_REG_ADDR_CONTROL_PORT_CLEAR			= 4 * 7,

    VIDEO_REG_ADDR_INPUT_CONTROL				= 4 * 8,
    VIDEO_REG_ADDR_INPUT_STATUS				= 4 * 8,

    VIDEO_REG_ADDR_INPUT_CLIP_X_CONTROL		= 4 * 9,
    VIDEO_REG_ADDR_INPUT_CLIP_F0_Y_CONTROL	= 4 * 10,
    VIDEO_REG_ADDR_INPUT_CLIP_F1_Y_CONTROL	= 4 * 11,

    VIDEO_REG_ADDR_INPUT_TIMESTAMP_LOW		= 4 * 12,
    VIDEO_REG_ADDR_INPUT_TIMESTAMP_HIGH		= 4 * 13,
    VIDEO_REG_ADDR_INPUT_FRAME_INFO			= 4 * 14,

    VIDEO_REG_ADDR_VFS_FULL_TIMESTAMP_LOW		= 4 * 15,
    VIDEO_REG_ADDR_VFS_FULL_TIMESTAMP_HIGH	= 4 * 16,
    VIDEO_REG_ADDR_VFS_FULL_FRAME_INFO		= 4 * 17,
    VIDEO_REG_ADDR_VFS_FULL_STRIPE_INFO		= 4 * 18,

    VIDEO_REG_ADDR_VFS_QUARTER_TIMESTAMP_LOW	= 4 * 19,
    VIDEO_REG_ADDR_VFS_QUARTER_TIMESTAMP_HIGH	= 4 * 20,
    VIDEO_REG_ADDR_VFS_QUARTER_FRAME_INFO		= 4 * 21,
    VIDEO_REG_ADDR_VFS_QUARTER_STRIPE_INFO	= 4 * 22,

    VIDEO_REG_ADDR_VFS_FULL_LINE_CONTROL		= 4 * 23,
    VIDEO_REG_ADDR_VFS_FULL_MAX_LINE_ID		= 4 * 24,

    VIDEO_REG_ADDR_VFS_QUARTER_LINE_CONTROL	= 4 * 25,
    VIDEO_REG_ADDR_VFS_QUARTER_MAX_LINE_ID	= 4 * 26,

    VIDEO_REG_ADDR_INPUT_CLIP_P1_F0_Y_CONTROL = 4 * 27,
    VIDEO_REG_ADDR_INPUT_CLIP_P1_F1_Y_CONTROL = 4 * 28,

    VIDEO_REG_ADDR_VPP_BORDER_CONTROL_1		= 4 * 30,
    VIDEO_REG_ADDR_VPP_BORDER_CONTROL_2		= 4 * 31,

    VIDEO_REG_ADDR_VPP_WB_CONTROL				= 4 * 32,
    VIDEO_REG_ADDR_VPP_WB_STATUS				= 4 * 32,

    VIDEO_REG_ADDR_VPP_WB_FBWR_CONTROL		= 4 * 33,
    VIDEO_REG_ADDR_VPP_WB_FBWR_ADDRESS		= 4 * 34,
    VIDEO_REG_ADDR_VPP_WB_FBWR_STRIDE			= 4 * 35,
    VIDEO_REG_ADDR_VPP_WB_FBWR_LINE_CONTROL	= 4 * 36,

    VIDEO_REG_ADDR_VPP1_BASE					= 4 * 40,
    VIDEO_REG_ADDR_VPP2_BASE					= 4 * 80
};

enum VPP_REG_OFFSET {
    VPP_REG_OFFSET_CONTROL				= 4 * 0,
    VPP_REG_OFFSET_STATUS				= 4 * 0,

    VPP_REG_OFFSET_FBRD_CONTROL			= 4 * 1,
    VPP_REG_OFFSET_FBRD_ADDRESS			= 4 * 2,
    VPP_REG_OFFSET_FBRD_STRIDE			= 4 * 3,
    VPP_REG_OFFSET_FBRD_LINE_CONTROL	= 4 * 4,

    VPP_REG_OFFSET_SCALER_X_CONTROL		= 4 * 5,
    VPP_REG_OFFSET_SCALER_Y_CONTROL		= 4 * 6,
    VPP_REG_OFFSET_SCALER_INPUT_SIZE	= 4 * 7,

    VPP_REG_OFFSET_BORDER_SIZE			= 4 * 8,
    VPP_REG_OFFSET_BORDER_X_CONTROL		= 4 * 9,
    VPP_REG_OFFSET_BORDER_Y_CONTROL		= 4 * 10,

    VPP_REG_OFFSET_BLANK_CONTROL_1		= 4 * 11,
    VPP_REG_OFFSET_BLANK_CONTROL_2		= 4 * 12,

    VPP_REG_OFFSET_MATRIX_RV_COEFF_1	= 4 * 13,
    VPP_REG_OFFSET_MATRIX_RV_COEFF_2	= 4 * 14,
    VPP_REG_OFFSET_MATRIX_RV_RANGE		= 4 * 15,
    VPP_REG_OFFSET_MATRIX_GY_COEFF_1	= 4 * 16,
    VPP_REG_OFFSET_MATRIX_GY_COEFF_2	= 4 * 17,
    VPP_REG_OFFSET_MATRIX_GY_RANGE		= 4 * 18,
    VPP_REG_OFFSET_MATRIX_BU_COEFF_1	= 4 * 19,
    VPP_REG_OFFSET_MATRIX_BU_COEFF_2	= 4 * 20,
    VPP_REG_OFFSET_MATRIX_BU_RANGE		= 4 * 21,

    VPP_REG_OFFSET_OSD_CONTROL			= 4 * 22,
    VPP_REG_OFFSET_OSD_ADDRESS			= 4 * 23,
    VPP_REG_OFFSET_OSD0_X_CONTROL		= 4 * 24,
    VPP_REG_OFFSET_OSD0_Y_CONTROL		= 4 * 25,
    VPP_REG_OFFSET_OSD1_X_CONTROL		= 4 * 26,
    VPP_REG_OFFSET_OSD1_Y_CONTROL		= 4 * 27,
    VPP_REG_OFFSET_OSD2_X_CONTROL		= 4 * 28,
    VPP_REG_OFFSET_OSD2_Y_CONTROL		= 4 * 29,
    VPP_REG_OFFSET_OSD3_X_CONTROL		= 4 * 30,
    VPP_REG_OFFSET_OSD3_Y_CONTROL		= 4 * 31
};



// A/V input type & source
typedef enum _MWCAP_VIDEO_INPUT_TYPE {
	MWCAP_VIDEO_INPUT_TYPE_NONE					= 0x00,
	MWCAP_VIDEO_INPUT_TYPE_HDMI					= 0x01,
	MWCAP_VIDEO_INPUT_TYPE_VGA					= 0x02,
	MWCAP_VIDEO_INPUT_TYPE_SDI					= 0x04,
	MWCAP_VIDEO_INPUT_TYPE_COMPONENT			= 0x08,
	MWCAP_VIDEO_INPUT_TYPE_CVBS					= 0x10,
	MWCAP_VIDEO_INPUT_TYPE_YC					= 0x20
} MWCAP_VIDEO_INPUT_TYPE;

typedef enum _MWCAP_AUDIO_INPUT_TYPE {
    MWCAP_AUDIO_INPUT_TYPE_NONE                 = 0x00,
	MWCAP_AUDIO_INPUT_TYPE_HDMI					= 0x01,
	MWCAP_AUDIO_INPUT_TYPE_SDI					= 0x02,
	MWCAP_AUDIO_INPUT_TYPE_LINE_IN				= 0x04,
	MWCAP_AUDIO_INPUT_TYPE_MIC_IN				= 0x08
} MWCAP_AUDIO_INPUT_TYPE;

typedef enum _MWCAP_PCIE_LINK_TYPE {
	MWCAP_PCIE_LINK_GEN_1						= 0x01,
	MWCAP_PCIE_LINK_GEN_2						= 0x02,
	MWCAP_PCIE_LINK_GEN_3						= 0x04,
	MWCAP_PCIE_LINK_GEN_4						= 0x08
} MWCAP_PCIE_LINK_TYPE;

typedef enum _MWCAP_VIDEO_TIMING_TYPE {
	MWCAP_VIDEO_TIMING_NONE						= 0x00000000,
	MWCAP_VIDEO_TIMING_LEGACY					= 0x00000001,
	MWCAP_VIDEO_TIMING_DMT						= 0x00000002,
	MWCAP_VIDEO_TIMING_CEA						= 0x00000004,
	MWCAP_VIDEO_TIMING_GTF						= 0x00000008,
	MWCAP_VIDEO_TIMING_CVT						= 0x00000010,
    MWCAP_VIDEO_TIMING_CVT_RB					= 0x00000020,
    MWCAP_VIDEO_TIMING_FAILSAFE					= 0x00002000
} MWCAP_VIDEO_TIMING_TYPE;

typedef enum _MWCAP_VIDEO_COLOR_FORMAT {
	MWCAP_VIDEO_COLOR_FORMAT_UNKNOWN			= 0x00,
	MWCAP_VIDEO_COLOR_FORMAT_RGB				= 0x01,
	MWCAP_VIDEO_COLOR_FORMAT_YUV601				= 0x02,
	MWCAP_VIDEO_COLOR_FORMAT_YUV709				= 0x03,
	MWCAP_VIDEO_COLOR_FORMAT_YUV2020			= 0x04,
	MWCAP_VIDEO_COLOR_FORMAT_YUV2020C			= 0x05				// Constant luminance, not supported yet.
} MWCAP_VIDEO_COLOR_FORMAT;

typedef enum _MWCAP_VIDEO_QUANTIZATION_RANGE {
	MWCAP_VIDEO_QUANTIZATION_UNKNOWN			= 0x00,
	MWCAP_VIDEO_QUANTIZATION_FULL				= 0x01, 			// Black level: 0, White level: 255/1023/4095/65535
	MWCAP_VIDEO_QUANTIZATION_LIMITED			= 0x02				// Black level: 16/64/256/4096, White level: 235(240)/940(960)/3760(3840)/60160(61440)
} MWCAP_VIDEO_QUANTIZATION_RANGE;

typedef enum _MWCAP_VIDEO_SATURATION_RANGE {
	MWCAP_VIDEO_SATURATION_UNKNOWN				= 0x00,
	MWCAP_VIDEO_SATURATION_FULL					= 0x01, 			// Min: 0, Max: 255/1023/4095/65535
	MWCAP_VIDEO_SATURATION_LIMITED				= 0x02, 			// Min: 16/64/256/4096, Max: 235(240)/940(960)/3760(3840)/60160(61440)
	MWCAP_VIDEO_SATURATION_EXTENDED_GAMUT		= 0x03  			// Min: 1/4/16/256, Max: 254/1019/4079/65279
} MWCAP_VIDEO_SATURATION_RANGE;

typedef enum _MWCAP_VIDEO_FRAME_TYPE {
    MWCAP_VIDEO_FRAME_2D							= 0x00,
    MWCAP_VIDEO_FRAME_3D_TOP_AND_BOTTOM_FULL		= 0x01,
    MWCAP_VIDEO_FRAME_3D_TOP_AND_BOTTOM_HALF		= 0x02,
    MWCAP_VIDEO_FRAME_3D_SIDE_BY_SIDE_FULL			= 0x03,
    MWCAP_VIDEO_FRAME_3D_SIDE_BY_SIDE_HALF			= 0x04
} MWCAP_VIDEO_FRAME_TYPE;

typedef enum _MWCAP_VIDEO_DEINTERLACE_MODE {
    MWCAP_VIDEO_DEINTERLACE_WEAVE				= 0x00,
    MWCAP_VIDEO_DEINTERLACE_BLEND				= 0x01,
    MWCAP_VIDEO_DEINTERLACE_TOP_FIELD			= 0x02,
    MWCAP_VIDEO_DEINTERLACE_BOTTOM_FIELD		= 0x03
} MWCAP_VIDEO_DEINTERLACE_MODE;

typedef enum _MWCAP_VIDEO_ASPECT_RATIO_CONVERT_MODE {
	MWCAP_VIDEO_ASPECT_RATIO_IGNORE				= 0x00,
	MWCAP_VIDEO_ASPECT_RATIO_CROPPING			= 0x01,
	MWCAP_VIDEO_ASPECT_RATIO_PADDING			= 0x02
} MWCAP_VIDEO_ASPECT_RATIO_CONVERT_MODE;

typedef enum _MWCAP_VIDEO_SYNC_TYPE {
	VIDEO_SYNC_ALL								= 0x07,
	VIDEO_SYNC_HS_VS							= 0x01,
	VIDEO_SYNC_CS								= 0x02,
	VIDEO_SYNC_EMBEDDED							= 0x04
} MWCAP_VIDEO_SYNC_TYPE;

struct xi_fmt {
    char  *name;
    u32    fourcc;          /* v4l2 format id */
    int    depth;
};


#define VPP_REG_ADDR(i, off) (((i) == 0 ? VIDEO_REG_ADDR_VPP1_BASE : VIDEO_REG_ADDR_VPP2_BASE) + (off))

#define MAX_WIDTH  2048
#define MAX_HEIGHT 2160
#define MIN_WIDTH  48
#define MIN_HEIGHT 32


void v4l2_process_one_frame(struct xi_stream_pipe *pipe, int iframe);

bool video_capture_GetInputFrameInfo(struct mag_cap_dev *vc, int * pnField, int * pnFieldIndex, int * pnFrameID);
u32 xi_device_get_vfs_frame_count(struct mag_cap_dev *device);

unsigned int video_capture_GetFullFrameBaseAddr(struct mag_cap_dev *vc, int iFrameID);

u32 xi_device_get_vfs_full_buffer_address(struct mag_cap_dev *device);

bool video_capture_GetVFSFullStripeInfo(
        struct mag_cap_dev *vc,
        int * pnField,
        int * pnFieldIndex,
        int * pnLineID,
        int * pnFrameID
        );

bool video_capture_GetVFSFullFrameInfo(
        struct mag_cap_dev *vc,
        int * pnField,
        int * pnFieldIndex,
        int * pnFrameID);

bool video_capture_GetVFSQuarterStripeInfo(
        struct mag_cap_dev *vc,
        int * pnLineID,
        int * pnFrameID
        );

bool video_capture_GetVFSQuarterFrameInfo(
                struct mag_cap_dev *vc,
                int * pnFrameID);

#endif

